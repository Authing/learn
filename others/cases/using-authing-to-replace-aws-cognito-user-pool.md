# Using Authing to replace AWS Cognito user pool

[Amazon Web Services](https://link.zhihu.com/?target=http%3A//aws.amazon.com/)\(AWS\) is the world's No. 1 cloud computing vendor, but their Cognito User Pool \(AWS's identity authentication solution\) is not perfect in China.

And Authing based in China can solve many problems with Cognito User Pool. Let's take a look at the introduction of Authing:

> [Authing](https://authing.cn) is an identity provider that provides enterprise-level identity and management solutions for customers in education, IoT, Internet and e-commerce.

[**Lambda**](https://link.zhihu.com/?target=https%3A//aws.amazon.com/lambda/) is a Function-as-a-Service \(FaaS\) platform provided by AWS. Lambda and the AWS ecosystem are very tightly integrated, and when you access Lambda, developers can use all the resources within the AWS ecosystem. For example, we can create a Lambda function that lets users log in via Cognito \(of course this article lets users log in using [Authing](https://link.zhihu.com/?target=https%3A//authing.cn/)\) and then call another Lambda function that can upload files to S3 \(AWS's storage service\).

One of the benefits of this type of platform \(now called Serverless\) is that developers can focus on business development without worrying about infrastructure.

The main purpose of this article is to show you how to use [Authing](https://link.zhihu.com/?target=https%3A//authing.cn/) + Lambda instead of AWS China's Cogito User Pool. Simply put, when you need a Lambda function or API Gateway for authentication, use Authing for authentication. [Click here to experience the final demo](https://sample.authing.cn/aws/).

![Demo Page](../../.gitbook/assets/image%20%2842%29.png)

In addition, Authing follows the OIDC specification, so this article will use OIDC for authentication. If you don't know what OIDC is, [check out this article](https://en.wikipedia.org/wiki/OpenID_Connect).

### Understand the operational process we are going to implement

1. Open the page: [https://sample.authing.cn/aws/](https://sample.authing.cn/aws/); 
2. Click Login to log in. At this point, the page will go to the login page of Authing \(the second-level domain name of the application\); 
3. Enter the account password to log in. `The test account is: email: test@authing.cn; password: 123456`; 
4. After the login is successful, return to the page opened in the first step, and display the avatar of the logged in user; At this point, the user can see the Private information returned from the AWS Lambda request; 

The architecture diagram is as follows:

![](../../.gitbook/assets/image%20%2833%29.png)

The final result is shown below:

![](../../.gitbook/assets/image%20%2824%29.png)

## Create an Authing app

If you have not registered for Authing, please [click here to register](https://authing.cn/login) by email and password. 

![](../../.gitbook/assets/image%20%2850%29.png)

After registration is complete, follow the steps below to create an Authing app.

![](../../.gitbook/assets/image%20%2837%29.png)

![](../../.gitbook/assets/image%20%2826%29.png)

![After the creation is completed, you will be taken to the application home page](../../.gitbook/assets/image%20%287%29.png)

In the console you can manage all the information of the application, including user management, mail management, SAML, OIDC, OAuth, LDAP, etc.

## Create an OIDC App

Once you've created your app, you have a user pool. Next you can create an OIDC app to authorize other programs \(your own or other third-party programs\) to access your user pool.

If you don't know what OIDC is, [check out this article](https://en.wikipedia.org/wiki/OpenID_Connect).

Please refer to the image below to create an OIDC app:

![](../../.gitbook/assets/image%20%2849%29.png)

![](../../.gitbook/assets/image%20%2856%29.png)

![Create an OIDC App](../../.gitbook/assets/image.png)

Here to explain, the authentication address when creating the OIDC application will be generated by Authing a second-level domain name \(support HTTPS\), and can not be repeated\(So you can't use test-oidc-app, please use another\), redirect\_uri fill in your own callback address, here I use [https://authing](https://authing).cn, note that the redirect\_uri is not allowed to be localhost in the OIDC protocol. Please use the proxy tool for debug.

![Click on &#x300C;&#x786E;&#x5B9A;&#x300D; to see that we have the first authorized application based on the OIDC protocol.](../../.gitbook/assets/image%20%2815%29.png)

## Initiate an authorization request

Similar to most OAuth applications, OIDC's authorized links also need to be spliced \(if you have access to Github, it should be easy to understand\), and the Authing OIDC application's authorized links conform to the standard specification. The format is:

> https://&lt;YOUR\_DOMAIN\_NAME&gt;.authing.cn/oauth/oidc/auth?client\_id=&lt;APP\_ID&gt;&redirect\_uri=&lt;redirect URL, must be exactly the same as platform configuration&gt;&scope=openid profile&response\_type=id\_token token&state=&lt;A random string used to protect against CSRF attacks&gt;

If you need to see detailed parameters, [please click here to view](https://docs.authing.cn/#/OIDCProvider/authorize?id=%E5%8F%91%E8%B5%B7%E6%8E%88%E6%9D%83)\(in Chinese\).

For example:

> [https://lambda.authing.cn/oauth/oidc/auth?client\_id=5cc41c06d14c740a0c93ba6f&redirect\_uri=https://authing.cn&scope=openid profile&response\_type=id\_token token&state=jacket](https://link.zhihu.com/?target=https%3A//lambda.authing.cn/oauth/oidc/auth%3Fclient_id%3D5cc41c06d14c740a0c93ba6f%26redirect_uri%3Dhttps%3A//authing.cn%26scope%3Dopenid)

For the sake of simplicity, our response\_type is set to "id\_token token", so you don't need to use "code" for tokens, the token will be attached directly to the redirect\_uri.

![If your authorization link is correct, you should see the login window like the one above.](../../.gitbook/assets/image%20%2855%29.png)

If your authorization link is correct, you should see the login window like the one above, and this form is also the form used by your users, they will login from here and redirect to your configured redirect\_uri.

You can try to sign up for an account and login. 

![Register](../../.gitbook/assets/image%20%2851%29.png)

After logging in, you can see the UI below:

![](../../.gitbook/assets/image%20%2832%29.png)

After you log in successfully, you should see the callback to the URL you filled in, with a lot of parameters, and we'll explain how to use these parameters.

![](../../.gitbook/assets/image%20%2831%29.png)

Now go back to the [Authing Dashboard](https://authing.cn) and you can see the user's registration and login data.

## Request for userInfo

After the redirect to the redirect\_uri configured in the dashboard, the following information is included:

```javascript
{
	"id_token": "JWT_TOKEN",
	"access_token": "JWT_TOKEN",
	"expires_in": "3600",
	"token_type": "Bearer",
	"state": "jacket",
	"session_state": "644d7b324ba61d517fdedd28b5b6e365d78f2a8178f2ee742474d5b57a99eb3f"
}
```

You can see that it contains access\_token and id\_token, where access\_token can help you get userInfo from the Authing backend, and id\_token contains basic information. If you want to get the user's avatar, you need to get it through access\_token.

Let's look at an example of id\_token first:

> eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6InIxTGtiQm8zOTI1UmIyWkZGckt5VTNNVmV4OVQyODE3S3gwdmJpNmlfS2MifQ.eyJzdWIiOiI1Y2MyYTg1MTFiYmFmMDRmOTNjZTQ4OWYiLCJub25jZSI6IjE4MzEyODkiLCJzaWQiOiI5MzkwZDA1ZC01ZTM3LTQ3ZWUtODJjNi1jNTQ1ZjA2ODhhMDAiLCJhdF9oYXNoIjoiNmxZMGRXajZYUTY0aExWdHAtR2tEdyIsInNfaGFzaCI6IlZVOU5QYV9JQ0VTSEdxRmxUZ3A2LUEiLCJhdWQiOiI1Y2MyYjU0OGQxNGM3NDJkYjg5M2JhNTUiLCJleHAiOjE1NTYzNjY0ODksImlhdCI6MTU1NjM2Mjg4OSwiaXNzIjoiaHR0cHM6Ly9vYXV0aC5hdXRoaW5nLmNuL29hdXRoL29pZGMifQ.Qc\_OMqMf6\_wwzW2SsEgEtiaGr3ZY1FWHnRrMU2M7LADGlNpq\_pvPrFxAVsR2j-BFr1y48M-Trvq6yAu4\_ZOUBHPtIIpoQ5W2bnABytUV693ZcwNlf9CCiLc-k0LG3o1U-BmiH3L6NAV7aKGsfVHS8toiNbVDuimPVdYJsRrF2C1jj1meM1K8FBVwqozXm6YtB--u3sqY4IszHnd5PMEWguLsOkpZJIh7xWeYPpVQ5WKfx0cA8rB\_T2puSCbeaUVhgIwNADy06qBqXhUOiA4gdcNbHtx7tvGZMxzMC3rdjpXoZk89Duh3O5tHlMtaBlidJGYavUSjVl7potESecSlBg

After parsing with [jwt.io,](https://jwt.io) you will get the following results:

```javascript
{
  "sub": "5cc2a8511bbaf04f93ce489f",
  "nonce": "1831289",
  "sid": "9390d05d-5e37-47ee-82c6-c545f0688a00",
  "at_hash": "6lY0dWj6XQ64hLVtp-GkDw",
  "s_hash": "VU9NPa_ICESHGqFlTgp6-A",
  "aud": "5cc2b548d14c742db893ba55",
  "exp": 1556366489,
  "iat": 1556362889,
  "iss": "https://oauth.authing.cn/oauth/oidc"
}
```

It includes fields such as the issuance time \(iat\) and expiration time \(exp\), which can be used to determine whether the user has been authenticated. In the OIDC specification, JWT uses the secret ID of the OIDC application and requires the developer to verify the backend \( In this step we will execute in Lambda\) and continue to execute the developer's own business process.

Let's take a look at an example of access\_token :

> eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6InIxTGtiQm8zOTI1UmIyWkZGckt5VTNNVmV4OVQyODE3S3gwdmJpNmlfS2MifQ.eyJqdGkiOiJza0p-bTNaYmZsTjVxVGEzR2J2YlMiLCJzdWIiOiI1Y2MyYTg1MTFiYmFmMDRmOTNjZTQ4OWYiLCJpc3MiOiJodHRwczovL29hdXRoLmF1dGhpbmcuY24vb2F1dGgvb2lkYyIsImlhdCI6MTU1NjM2Mjg4OSwiZXhwIjoxNTU2MzY2NDg5LCJzY29wZSI6Im9wZW5pZCBwcm9maWxlIiwiYXVkIjoiNWNjMmI1NDhkMTRjNzQyZGI4OTNiYTU1In0.Uf3YK4D9HL-G71hkA4cWt5kitDo5rNgwVA9Vqlv4RjAILNDTylYWtkacKJpLcOSS81ivaNpDVNYYzBSoyN-eMH80VhArPUre74F9SHdonA-IVFVPT0DHRtOAJI9kqDW4tgTXhZeZMUm-MCjVjR-q8XrayXaqrC5Hu5W3D1N-K\_jZOlwxzIBf51nuC4NMvSI\_wPpYj2WPzGxFwpfTCEbnhj5RO0CcThRpC3EdmpbtcJqStd7AZQhkLyTb1TQLHJOel8DSxLnLnoIU0rZXsodK6EjE\_oqRLagetNXF1cKfRmnGFaAKZKqgvHc527S\_CVkgXIwcHBRmDeqo93CCId\_hmQ

After parsing with [jwt.io,](https://jwt.io) you will get the following results:

```javascript
{
  "jti": "skJ~m3ZbflN5qTa3GbvbS",
  "sub": "5cc2a8511bbaf04f93ce489f",
  "iss": "https://oauth.authing.cn/oauth/oidc",
  "iat": 1556362889,
  "exp": 1556366489,
  "scope": "openid profile",
  "aud": "5cc2b548d14c742db893ba55"
}
```

You can see that access\_token is a lot less information than id\_token. The following paragraph explains the difference between access\_token and id\_token:

> **ID Tokens vs Access Tokens**. The ID Token is a security token granted by the OpenID Provider that contains information about an End-User. This information tells your client application that the user is authenticated, and can also give you information like their username or locale.You can pass an ID Token around different components of your client, and these components can use the ID Token to confirm that the user is authenticated and also to retrieve information about them.Access tokens, on the other hand, are not intended to carry information about the user. They simply allow access to certain defined server resources. More discussion about when to use access tokens can be found in Validating Access Tokens.

Simply put, id\_token tells you that the user has been authenticated, and access\_token is a credential that you can access the resource server \(here is Authing\).

At the same time, you can see that idtoken contains less information. If you want to get more information, you need to use access\_token to get it. The acquisition method is also very simple, just send a GET request to the following link and attach the access\_token, such as:

> $ curl [https://users.authing.cn/oauth/oidc/user/userinfo?access\_token=](https://link.zhihu.com/?target=https%3A//users.authing.cn/oauth/oidc/user/userinfo%3Faccess_token%3DeyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6InIxTGtiQm8zOTI1UmIyWkZGckt5VTNNVmV4OVQyODE3S3gwdmJpNmlfS2MifQ.eyJqdGkiOiJ3TU9FTHQ0NzhrNG53U295M21rZWsiLCJzdWIiOiI1YzlmNzVjN2NjZjg3YjA1YTkyMWU5YjAiLCJpc3MiOiJodHRwOi8vbG9jYWxob3N0OjU1NTYiLCJpYXQiOjE1NTQyNzI2NDAsImV4cCI6MTU1NDI3NjI0MCwic2NvcGUiOiJvcGVuaWQgcHJvZmlsZSIsImF1ZCI6IjVjYTQ0ZmMyMzNiYjcyMDY0MmVjZmQ2NiJ9.rmrxj9Vqt-E-61wRezYwn3NbezL4EmWcb_-OUGI9Y_TfiVcKnDYEbwC0M51qTcDBHn27-4BBoo60gu8OGKQJdmSKRApkJ4Z550eUrFAWxXztvy76EWtjmAmOD41GAu_EzNB5MAPZAEsX8I3kOan6Ylv_GonrHuzOL-GV3qb0R_COuCb7xVKKG4vyaJxWLq_bfA9E1VqKIkbg484GJKDy6Cfa_iIlurE6sLMhhFL1ycYpzMvX8ELEpgzOzMWL9U9gtNhPad9PK1h3dAHJjFvXYr9veIYOzjPwEy5eIkBZvqH8Gp4iV1v4sM6oWZefeoaN2cmeYkDWOk-mpiqAzyhw6g)&lt;ACCESS\_TOKEN&gt;

You can get information such as sub\(user id\)_. After getting the_ id, you can store the sub in your own database to complete your actual business.

```javascript
{
    "sub":"5cc2a8511bbaf04f93ce489f", // user id
    "nickname":"",
    "picture":"https://usercontents.authing.cn/authing-avatar.png"
}
```

The above JSON is a return result after using access\_token in exchange for user data.

Ok, now that we have got the Token, we need to verify the legitimacy of this token in Lambda and display different information on the front end.

## Write a Lambda function

Writing a Lambda function recommends using the Serverless CLI.

At the same time, you can[ check out the full code here](https://github.com/Authing/authing-lambda/blob/master/serverless-authorizer/handler.js).

Lambda is mainly used to do three things in this article:

1. Auth \_token is authenticated to obtain whether the user has been authenticated; 
2. Provide a Public API that can be accessed directly;
3. Provide a Private API that needs to be authenticated to be accessed; 

### Authenticate id\_token 

Authentication id\_token firstly needs to know the secret of the OIDC application. This value can be found in the details of the OIDC application in the Authing dashboard:

![](../../.gitbook/assets/image%20%2814%29.png)

![](../../.gitbook/assets/image%20%2830%29.png)

We use the jsonwebtoken library to verify the legitimacy of the id\_token

#### Install jsonwebtoken:

```text
$ npm install jsonwebtoken --save
```

P.S. After the package is introduced in the lambda, it is packaged and uploaded to the AWS Lambda runtime.

Code show as below:

```javascript
const jwt = require('jsonwebtoken');

// Policy helper function 
// This is the template code provided by AWS, no need to make changes here.
const generatePolicy = (principalId, effect, resource) => {
  const authResponse = {};
  authResponse.principalId = principalId;
  if (effect && resource) {
    const policyDocument = {};
    policyDocument.Version = '2012-10-17';
    policyDocument.Statement = [];
    const statementOne = {};
    statementOne.Action = 'execute-api:Invoke';
    statementOne.Effect = effect;
    statementOne.Resource = resource;
    policyDocument.Statement[0] = statementOne;
    authResponse.policyDocument = policyDocument;
  }
  return authResponse;
};

// Reusable Authorizer function, set on `authorizer` field in serverless.yml
module.exports.auth = async (event, context, cb) => {
  if (event.authorizationToken) {
    // remove "bearer " from token
    const token = event.authorizationToken.substring(7);

    try {
        // Use OIDC's secret to verify the legitimacy of id_token
        let decoded = jwt.verify(token, 'YOUR_OIDC_APP_SECRET'),
          expired = (Date.parse(new Date()) / 1000) > decoded.exp;
        if (expired) {
          cb('Unauthorized, Login information has expired.');
        }else {
          cb(null, generatePolicy('user', 'Allow', event.methodArn));
        }
      } catch (error) {
        cb('Unauthorized');
      }
  } else {
    cb('Unauthorized');
  }
};
```

We used OIDC's secret to verify the legitimacy of id\_token, The core code is on line 29:

```javascript
let decoded = jwt.verify(token, 'YOUR_OIDC_APP_SECRET')
```

### Public API

```javascript
// Public API
module.exports.publicEndpoint = (event, context, cb) => {
  cb(null, { message: 'Welcome to our Public API!' });
};
```

### Private API

```javascript
// Private API
module.exports.privateEndpoint = (event, context, cb) => {
  cb(null, { message: 'Only logged in users can see this' });
};
```

### serverless.yml

This file can be used to configure the route that needs to be authenticated, such as the privateEndpoint in the above code, and the authorizer is configured as the auth function.

```yaml
service: serverless-authorizer

provider: 
 name: aws
 runtime: nodejs8.10

functions:
  auth:
    handler: handler.auth
  getUserInfo:
    handler: handler.getUserInfo
    events:
      - http:
          path: api/userInfo
          method: get
          integration: lambda
          cors: true    
  publicEndpoint:
    handler: handler.publicEndpoint
    events:
      - http:
          path: api/public
          method: get
          integration: lambda
          cors: true
  privateEndpoint:
    handler: handler.privateEndpoint
    events:
      - http:
          path: api/private
          method: get
          integration: lambda
          authorizer: auth # See custom authorizer docs here: http://bit.ly/2gXw9pO
          cors: true
```

[Click here to view the full code.](https://github.com/Authing/authing-lambda/blob/master/serverless-authorizer/handler.js)

### Test Lambda

We need to test after writing the code.

Lambda supports local testing, you can use the following command:

```text
$ sls invoke local -f auth --data '{"authorizationToken": "Bearer <id_token>"}'
```

If the local test returns the following information, the verification is successful:

```javascript
{
    "principalId": "user"
}
```

### Deploy Lambda

```haskell
$ serverless deploy
```

After the deployment is complete, you will get three links, which are the three functions of the above code.

![](../../.gitbook/assets/image%20%2844%29.png)

Use curl or postman to carry the OIDC logged id\_token into the header's Authorization to see the result, such as:

```haskell
$ curl --header "Authorization: <id_token>" <endpoint>
```

The result of the above three routes should be:

```text
curl <endpoint/dev/api/public> - Should work! Public!
curl <endpoint/dev/api/private> - Should not work
curl --header "Authorization: <id_token>" <endpoint/dev/api/private> - Should work! Authorized!
```

Finally, add relevant information to our front end. You should see the following information after clicking Login:

![](../../.gitbook/assets/image%20%2847%29.png)

Live demo: [https://sample.authing.cn/aws](https://sample.authing.cn/aws)

Github: [https://github.com/Authing/authing-lambda](https://github.com/Authing/authing-lambda)

Enojoy!

Authing.cn - the leading identity authentication cloud.

![](../../.gitbook/assets/image%20%2853%29.png)



